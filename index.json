[{"categories":["算法"],"content":"原题链接：https://leetcode.com/problems/binary-tree-maximum-path-sum/ 这道题是要在一棵二叉树中寻找一条路径，使得该路径上的节点的和（Path Sum）最大。这里的路径是图论中的路径，即可以从任意一点开始到任意一点结束，而不是通常见到的从根节点开始的路径。 在二叉树里面，Path Sum最大的路径必然包含一个高度最高的节点（即最接近根节点的那个节点），该路径以该节点为中心，分别向该节点的左子树和右子树延伸。因此，我们只需要对于树中的每个节点，都计算一下以该节点为最高节点的Path Sum的最大值，这些最大值中的最大值就是最终的结果（即该二叉树的最大Path Sum）。为此，我们可以定义一个递归函数recur(node)，去计算以node为最高节点并且只向一边延伸（左子树或者右子树）的Path Sum的最大值，这个值可以根据recur(node.left)和recur(node.right)来计算。与此同时，以node为最高节点的Path Sum的最大值（不限制延伸的方向）也可以根据recur(node.left)和recur(node.right)计算出来。具体代码如下： // Author: Zhiyang Li // Date: 2020.05.22 /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {number} */ // 返回以node为最高节点，并且只向一边延伸的Path Sum的最大值。 // result用于存放最终结果 function recur(node, result) { if (node === null) return 0; let l1 = recur(node.left, result); let r1 = recur(node.right, result); let cur1 = Math.max(l1, r1, 0); let cur1l = Math.max(l1, 0); let cur1r = Math.max(r1, 0); // 计算以node为最高节点的Path Sum的最大值，如果大于result.value // 就更新result.value if (node.val + cur1l + cur1r \u003e result.value) { result.value = node.val + cur1l + cur1r; } return node.val + cur1; } var maxPathSum = function(root) { let result = {value: -Infinity}; recur(root, result); return result.value; }; 由于该算法只访问了每个节点1次，因此时间复杂度为$O(n)$。 ","date":"2020-05-22","objectID":"/posts/leetcode124/:0:0","tags":["LeetCode","Algorithm"],"title":"LeetCode 124: Binary Tree Maximum Path Sum","uri":"/posts/leetcode124/"},{"categories":["算法"],"content":"原题链接：https://leetcode.com/problems/flatten-binary-tree-to-linked-list/ 这道题的题意是要实现一个flatten函数，把一棵二叉树按照先序遍历的顺序变成一个单链表。看到二叉树就想到递归，这道题也是可以通过递归来做的。我们要flatten一棵树，实际上就是把它的左子树和右子树都进行flatten操作，然后把左子树flatten的结果接到根节点上，右子树flatten的结果接到左子树flatten之后的最后一个节点上。下面的代码就是基于这个思路： // Author: Zhiyang Li // Date: 2020.05.19 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: void flatten(TreeNode* root) { if (root == nullptr) return; TreeNode *l = root-\u003eleft; TreeNode *r = root-\u003eright; root-\u003eleft = nullptr; root-\u003eright = l; flatten(l); flatten(r); TreeNode *p = root; while (p-\u003eright != nullptr) { p = p-\u003eright; } p-\u003eright = r; } }; 然而，上面的算法效率并不是很高，主要问题在于需要寻找左子树flatten的结果的最后一个节点。这个操作会把左子树的所有节点都访问一次，导致在递归过程中，有很多节点被重复访问了很多次，越往左下角访问的次数越多。 论坛中有人提出了另一种递归的算法。这个算法不是很好理解，不过它的大致思路是按照先序遍历的逆序来构造单链表。先序遍历的访问顺序是根节点-左子树-右子树，因此该算法是按照右子树-左子树-根节点的顺序来进行访问和单链表构造的。这也是一个比较常用的思路。例如，对一棵二叉树进行后序遍历时，如果要求不使用递归，那么一个比较简单的方法是按照后序遍历的逆序，即根节点-右子树-左子树来进行遍历，再把结果倒过来。这个的话用一个栈就可以轻松做到。 论坛中还有另一个不使用递归的算法。该算法的思路是，对于当前访问的节点N，找到N的左子树的最右端的节点X，然后把X的right指针指向N的右子树。即相当于把N的右子树进行移动，成为X的右子树。这样操作前后，以N为根的子树的先序遍历的结果是不变的。所以我们可以继续只对N的左子树进行下一步的同样的操作，直到把所有的节点都遍历完。这个思路类似于Morris Traversal，时间复杂度应该是$O(n)$。 ","date":"2020-05-19","objectID":"/posts/leetcode114/:0:0","tags":["LeetCode","Algorithm"],"title":"LeetCode 114: Flatten Binary Tree to Linked List","uri":"/posts/leetcode114/"},{"categories":["算法"],"content":"参考资料 https://leetcode.com/problems/flatten-binary-tree-to-linked-list/discuss/36977/My-short-post-order-traversal-Java-solution-for-share https://leetcode.com/problems/flatten-binary-tree-to-linked-list/discuss/37010/Share-my-simple-NON-recursive-solution-O(1)-space-complexity! ","date":"2020-05-19","objectID":"/posts/leetcode114/:1:0","tags":["LeetCode","Algorithm"],"title":"LeetCode 114: Flatten Binary Tree to Linked List","uri":"/posts/leetcode114/"},{"categories":["算法"],"content":"原题链接：https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/ 这道题要求根据一棵二叉树的先序遍历（Preorder）和中序遍历（Inorder）的结果重建这棵树。首先，我们知道，先序遍历是按照根节点-左子树-右子树的顺序遍历的，而中序遍历是按照左子树-根节点-右子树的顺序遍历的。所以，一棵树的先序遍历和中序遍历的结果实际上具有以下结构： 遍历结果的结构遍历结果的结构 \"\r遍历结果的结构\r 看到这里，我们应该就清楚这道题应该用递归来做了。递归过程中，对于某棵子树的先序和中序遍历结果，先序遍历结果的第一个值（不妨称为x）是该子树的根节点，然后我们在中序遍历结果中去寻找x，x的左边就是该子树的左子树的中序遍历结果，右边就是该子树的右子树的中序遍历结果。知道了左子树的中序遍历结果，也就知道了左子树的节点数，这样再回到先序遍历结果，我们就知道左子树以及右子树的先序遍历结果了。然后对于左子树和右子树分别进行递归即可。具体代码如下： // Author: Zhiyang Li // Date: 2020.05.18 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* buildTree(vector\u003cint\u003e\u0026 preorder, vector\u003cint\u003e\u0026 inorder) { if (preorder.size() == 0 \u0026\u0026 inorder.size() == 0) return nullptr; int rootVal = preorder[0]; TreeNode *root = new TreeNode(rootVal); int rootInd; for (int i = 0;i \u003c inorder.size();i++) { if (inorder[i] == rootVal) { rootInd = i; break; } } vector\u003cint\u003e leftPre(preorder.begin() + 1, preorder.begin() + 1 + rootInd); vector\u003cint\u003e leftIn(inorder.begin(), inorder.begin() + rootInd); vector\u003cint\u003e rightPre(preorder.begin() + 1 + rootInd, preorder.end()); vector\u003cint\u003e rightIn(inorder.begin() + rootInd + 1, inorder.end()); TreeNode *left = buildTree(leftPre, leftIn); TreeNode *right = buildTree(rightPre, rightIn); root-\u003eleft = left; root-\u003eright = right; return root; } }; 对于平衡二叉树，该算法的时间复杂度是$O(nlogn)$（可以按照$T(n) = 2T(\\frac{n}{2}) + O(n)$计算）。这里我们在每一次递归过程中都需要$O(n)$的时间来寻找根节点在中序遍历结果中的位置。实际上，我们可以在一开始就利用一个Hash Map来存储每个节点在中序遍历结果中的位置，后面递归时只需要在这个Hash Map中查找即可，时间复杂度为$O(1)$，这样就把整个算法的时间复杂度降低到了$O(n)$（可以按照$T(n) = 2T(\\frac{n}{2}) + O(1)$计算）。修改后的具体代码如下： // Author: Zhiyang Li // Date: 2020.05.18 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { private: TreeNode * recur(vector\u003cint\u003e\u0026 preorder, vector\u003cint\u003e\u0026 inorder, unordered_map\u003cint, int\u003e \u0026map, int preBegin, int preEnd, int inBegin, int inEnd) { if (preBegin == preEnd \u0026\u0026 inBegin == inEnd) return nullptr; int rootVal = preorder[preBegin]; TreeNode *root = new TreeNode(rootVal); int rootInd = map[rootVal]; int numLeft = rootInd - inBegin; TreeNode *left = recur(preorder, inorder, map, preBegin + 1, preBegin + 1 + numLeft, inBegin, rootInd); TreeNode *right = recur(preorder, inorder, map, preBegin + 1 + numLeft, preEnd, rootInd + 1, inEnd); root-\u003eleft = left; root-\u003eright = right; return root; } public: TreeNode* buildTree(vector\u003cint\u003e\u0026 preorder, vector\u003cint\u003e\u0026 inorder) { unordered_map\u003cint, int\u003e map; for (int i = 0;i \u003c inorder.size();i++) { map[inorder[i]] = i; } int n = preorder.size(); return recur(preorder, inorder, map, 0, n, 0, n); } }; 论坛中还有人提到说不用Hash Map也可以在$O(n)$时间内实现这个算法（https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/discuss/34543/Simple-O(n)-without-map），这个有空再来分析一下。 ","date":"2020-05-18","objectID":"/posts/leetcode105/:0:0","tags":["LeetCode","Algorithm"],"title":"LeetCode 105: Construct Binary Tree from Preorder and Inorder Traversal","uri":"/posts/leetcode105/"},{"categories":["JavaScript"],"content":"JavaScript引擎是基于Event Loop来运行的，不断处理队列中的各项任务。Event Loop包含一个调用栈（Stack），若干个任务队列（Queue）和一个堆（Heap）。它的工作模式就是不断从任务队列中取出任务放入栈中执行，一次只执行一个任务，当前任务执行完之后再从任务队列中取出下一个任务开始执行。当我们把Promise以及async/await也考虑进Event Loop时，各项任务的执行顺序就变得稍显复杂。 这里谈谈我在查阅一些资料之后对于它们的理解。 ","date":"2020-05-14","objectID":"/posts/%E6%B5%85%E6%9E%90promiseasync+await%E4%B8%8Eevent-loop/:0:0","tags":["JavaScript","Promise","Event Loop"],"title":"浅析Promise、async/await与Event Loop","uri":"/posts/%E6%B5%85%E6%9E%90promiseasync+await%E4%B8%8Eevent-loop/"},{"categories":["JavaScript"],"content":"宏任务（Macrotask） 在Event Loop中，其中一个任务队列被称为宏任务队列（Macrotask Queue），用于存放各种宏任务。属于宏任务的主要有以下几种： JS脚本 setTimeout、setInterval中的callback函数 用于处理各种事件（如click、mousemove）的handler函数 一个比较经典的关于Event Loop和宏任务的问题就是setTimeout中的callback的执行顺序问题。例如下面的代码： console.log(0); setTimeout(() =\u003e console.log(1), 0); console.log(2); 该代码的输出顺序应该是0, 2, 1。这里虽然setTimeout的第二个参数被设置为0，但其中的callback仍然在console.log(2)之后执行，因为当前栈中的任务是上面的脚本，setTimeout中的callback是被放入了宏任务队列中，只有在上面的脚本执行结束之后，这个callback才会被放入栈中执行。具体的执行步骤如下： 上述脚本被放入栈中 执行console.log(0)，输出0 执行setTimeout，开启一个线程用于计时。由于延时被设置为0，因此计时立刻结束，callback被放入宏任务队列中 执行console.log(2)，输出2 脚本执行完毕，callback被放入栈中开始执行，输出1 ","date":"2020-05-14","objectID":"/posts/%E6%B5%85%E6%9E%90promiseasync+await%E4%B8%8Eevent-loop/:1:0","tags":["JavaScript","Promise","Event Loop"],"title":"浅析Promise、async/await与Event Loop","uri":"/posts/%E6%B5%85%E6%9E%90promiseasync+await%E4%B8%8Eevent-loop/"},{"categories":["JavaScript"],"content":"Promise与Event Loop 对于Promise，首先其构造函数中的参数（function (resolve, reject) {}）是同步执行的，即在构造Promise时会立即执行，执行完毕后才会返回构造好的Promise对象。另外，在Promise settle之后，then/catch/finally中的handler函数会被放入另一个任务队列，称为微任务队列（Microtask Queue）。JS引擎在执行完当前的宏任务之后，会先把微任务队列中的所有任务都执行完毕（包括执行过程中新加入的微任务），再去执行宏任务队列中的下一个宏任务。除了Promise的handler函数之外，我们还可以通过queueMicrotask将一个函数放入微任务队列中。 对于下面的例子： console.log(0); Promise.resolve().then(() =\u003e console.log(1)).then(() =\u003e console.log(2)); setTimeout(() =\u003e console.log(3), 0); console.log(4); 上述代码的输出为0, 4, 1, 2, 3。具体的步骤如下： 上述脚本被放入栈中 执行console.log(0)，输出0 Promise.resolve()返回一个fulfilled promise，因此函数() =\u003e console.log(1)被放入微任务队列中 执行setTimeout，函数() =\u003e console.log(3)被放入宏任务队列中 执行console.log(4)，输出4，上述脚本执行完毕 从微任务队列中取出函数() =\u003e console.log(1)并执行，输出1。该函数相当于返回一个fulfilled promise，因此() =\u003e console.log(2)又被 放入微任务队列中 从微任务队列中取出函数() =\u003e console.log(2)并执行，输出2 微任务队列已经清空，从宏任务队列中取出函数() =\u003e console.log(3)并执行，输出3 我们再来看一个例子： console.log(0); new Promise(function(resolve, reject) { console.log(1); setTimeout(() =\u003e console.log(2), 0); resolve(); }).then(() =\u003e console.log(3)); console.log(4); 这个代码的输出将会是0, 1, 4, 3, 2。具体步骤如下： 上述脚本被放入栈中 执行console.log(0)，输出0 执行Promise构造函数中的内容。首先执行console.log(1)，输出1；然后执行setTimeout，将() =\u003e console.log(2)放入宏任务队列中； 最后执行resolve，使得该promise变成一个fulfilled promise。 由于promise已经fulfilled，函数() =\u003e console.log(3)被放入微任务队列中 执行console.log(4)，输出4，上述脚本执行完毕 从微任务队列中取出函数() =\u003e console.log(3)并执行，输出3 微任务队列已经清空，从宏任务队列中取出函数() =\u003e console.log(2)并执行，输出2 ","date":"2020-05-14","objectID":"/posts/%E6%B5%85%E6%9E%90promiseasync+await%E4%B8%8Eevent-loop/:2:0","tags":["JavaScript","Promise","Event Loop"],"title":"浅析Promise、async/await与Event Loop","uri":"/posts/%E6%B5%85%E6%9E%90promiseasync+await%E4%B8%8Eevent-loop/"},{"categories":["JavaScript"],"content":"async/await与Event Loop async/await被称作是Promise的语法糖，所以要分析包含async/await的代码的执行顺序，我们需要理解async/await内部是如何通过Promise来实现的。下面谈谈我在查阅一些资料后的个人理解。 对于下面的async函数的伪代码： async function func() { doSomething(); let result = await A; processResult(result); } 实际上await后面的内容相当于Promise A的handler函数。也就是说，上面的代码等价于： async function func() { doSomething(); A.then((result) =\u003e { processResult(result); }); } 因此，当我们的调用栈进入async函数内部，遇到await之后，会把await右边的Promise中的同步内容执行完，然后退出该async函数去执行该函数后面的同步内容。如果await右侧的Promise resolve了，那么该async函数剩下的部分会被放入微任务队列中。 例如，对于下面的代码： async function func1() { console.log(1); await func2(); console.log(2); } async function func2() { console.log(3); } console.log(0); func1().then(() =\u003e console.log(4)); setTimeout(() =\u003e console.log(5), 0) console.log(6); 其输出顺序将会是0, 1, 3, 6, 2, 4, 5。具体分析如下： 上述脚本被放入栈中 执行console.log(0)，输出0 进入func1函数，执行console.log(1)，输出1 进入func2函数，执行console.log(3)，输出3，并返回一个fulfilled promise（值为undefined）。func1函数await后面的部分被放入微任务队列中。 执行setTimeout，将函数() =\u003e console.log(5)放入宏任务队列中 执行console.log(6)，输出6。脚本结束，调用栈清空 从微任务队列中取出func1函数await后面的部分开始执行，输出2。由于func1返回了一个fulfilled promise（值为undefined），因此函数() =\u003e console.log(4)被放入微任务队列中 从微任务队列中取出函数() =\u003e console.log(4)执行，输出4 微任务队列为空，从宏任务队列中取出() =\u003e console.log(5)并执行，输出5 ","date":"2020-05-14","objectID":"/posts/%E6%B5%85%E6%9E%90promiseasync+await%E4%B8%8Eevent-loop/:3:0","tags":["JavaScript","Promise","Event Loop"],"title":"浅析Promise、async/await与Event Loop","uri":"/posts/%E6%B5%85%E6%9E%90promiseasync+await%E4%B8%8Eevent-loop/"},{"categories":["JavaScript"],"content":"参考资料 https://segmentfault.com/a/1190000017554062 https://juejin.im/post/5c148ec8e51d4576e83fd836 https://www.cnblogs.com/beyondcheng/p/3440154.html https://juejin.im/post/5c9a43175188252d876e5903 https://javascript.info/microtask-queue https://javascript.info/event-loop ","date":"2020-05-14","objectID":"/posts/%E6%B5%85%E6%9E%90promiseasync+await%E4%B8%8Eevent-loop/:4:0","tags":["JavaScript","Promise","Event Loop"],"title":"浅析Promise、async/await与Event Loop","uri":"/posts/%E6%B5%85%E6%9E%90promiseasync+await%E4%B8%8Eevent-loop/"},{"categories":["博客搭建"],"content":"Hugo是一个基于Go语言的静态网站构建工具，它提供了大量可供选择的模板主题（Theme），帮助我们更加快捷地搭建自己的网站，并且可以非常方便地部署在GitHub Pages上。 下面分享一下我利用Hugo和Github Pages搭建博客网站（也就是这个网站）的一些经验。 ","date":"2020-05-09","objectID":"/posts/%E4%BD%BF%E7%94%A8hugo+github-pages%E6%9E%84%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/:0:0","tags":["Hugo","Github Pages"],"title":"使用Hugo+GitHub Pages构建博客网站","uri":"/posts/%E4%BD%BF%E7%94%A8hugo+github-pages%E6%9E%84%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"},{"categories":["博客搭建"],"content":"Hugo安装 Hugo支持各种主流操作系统。对于Windows系统，我们可以直接使用预先编译好的可执行文件（https://github.com/gohugoio/hugo/releases）。Windows下的可执行文件有两个版本，一个是常规版本，另一个是扩展版本（extended），这两个版本的区别在于后者支持Sass，而前者不支持，所以如果后面选择的模板主题中使用了Sass，就必须下载扩展版本。 下载完成之后，我们可以把Hugo可执行文件添加到环境变量Path中，方便在命令行中调用。 ","date":"2020-05-09","objectID":"/posts/%E4%BD%BF%E7%94%A8hugo+github-pages%E6%9E%84%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/:1:0","tags":["Hugo","Github Pages"],"title":"使用Hugo+GitHub Pages构建博客网站","uri":"/posts/%E4%BD%BF%E7%94%A8hugo+github-pages%E6%9E%84%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"},{"categories":["博客搭建"],"content":"网站构建 首先在命令行中执行hugo new site personal_blog，这会在当前目录下新建一个名为personal_blog的目录，并在该目录下生成一些初始文件及目录： 初始文件及目录初始文件及目录 \"\r初始文件及目录\r 其中一些文件及目录的作用如下： config.toml: 网站的配置文件，可以用于设置网站的标题、语言、使用的模板主题、作者信息等等，具体选项可以参考各个模板主题的文档 themes: 用于存放模板主题相关的文件 static: 可用于存放网站用到的图像、视频、音乐等资源 content: 用于存放Markdown文件，如撰写的博客文档 接下来我们可以前往https://themes.gohugo.io/选择一个喜欢的模板主题。里面有非常非常多的主题可供选择： 主题主题 \"\r主题\r 这里以主题LoveIt为例进行说明。首先我们进入personal_blog目录，然后在命令行中执行以下命令将该主题下载到themes目录中： git init git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt 然后在配置文件中加入如下内容，指定使用的主题和版本（注意不要删去原有内容）： theme = \"LoveIt\" [params] version = \"0.2.X\" 这样基本的网站框架就搭建好了。我们可以在本地启动服务查看网站的效果，方法是在命令行中输入hugo server，然后访问网址localhost:1313/。大致的效果如下： 网站框架网站框架 \"\r网站框架\r ","date":"2020-05-09","objectID":"/posts/%E4%BD%BF%E7%94%A8hugo+github-pages%E6%9E%84%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/:2:0","tags":["Hugo","Github Pages"],"title":"使用Hugo+GitHub Pages构建博客网站","uri":"/posts/%E4%BD%BF%E7%94%A8hugo+github-pages%E6%9E%84%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"},{"categories":["博客搭建"],"content":"网站配置 刚才我们看到的网站非常简陋，因此接下来我们需要对网站进行配置以丰富网站的内容，方法是对配置文件config.toml进行修改。不同的模板主题支持的参数可能不太一样，我们选择的主题LoveIt所支持的各种参数和功能可以参考其文档。下面是一个比较简单的配置文件的例子，主要设置了语言、标题、主题、主题版本、搜索、菜单栏、作者等。 baseURL = \"http://example.org/\" # [en, zh-cn, fr, ...] 设置默认的语言 defaultContentLanguage = \"zh-cn\" # 网站语言, 仅在这里 CN 大写 languageCode = \"zh-CN\" # 是否包括中日韩文字 hasCJKLanguage = true # 网站标题 title = \"志洋的博客\" # 更改使用 Hugo 构建网站时使用的默认主题 theme = \"LoveIt\" [params] # LoveIt 主题版本 version = \"0.2.X\" defaultTheme = \"dark\" [params.search] enable = true # type of search engine (\"lunr\", \"algolia\") type = \"lunr\" # max index length of the chunked content contentLength = 4000 # placeholder of the search bar placeholder = \"\" # LoveIt NEW | 0.2.1 max number of results length maxResultLength = 10 # LoveIt NEW | 0.2.3 snippet length of the result snippetLength = 30 # LoveIt NEW | 0.2.1 HTML tag name of the highlight part in results highlightTag = \"em\" # LoveIt NEW | 0.2.4 whether to use the absolute URL based on the baseURL in search index absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" [menu] [[menu.main]] identifier = \"posts\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" name = \"文章\" url = \"/posts/\" # 当你将鼠标悬停在此菜单链接上时, 将显示的标题 title = \"\" weight = 1 [[menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" weight = 2 [[menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" weight = 3 [[menu.main]] identifier = \"github\" pre = \"\u003ci class='fab fa-github fa-fw'\u003e\u003c/i\u003e\" post = \"\" name = \"\" url = \"https://github.com/lzyang1995\" title = \"GitHub\" weight = 4 [outputs] home = [\"HTML\", \"RSS\", \"JSON\"] [author] name = \"李志洋\" 设置修改完成后，网站的大致效果如下： 修改设置后的效果修改设置后的效果 \"\r修改设置后的效果\r ","date":"2020-05-09","objectID":"/posts/%E4%BD%BF%E7%94%A8hugo+github-pages%E6%9E%84%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/:3:0","tags":["Hugo","Github Pages"],"title":"使用Hugo+GitHub Pages构建博客网站","uri":"/posts/%E4%BD%BF%E7%94%A8hugo+github-pages%E6%9E%84%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"},{"categories":["博客搭建"],"content":"撰写博客 我们可以通过hugo new命令来新建一篇博文，如hugo new posts/my-first-post.md，这样会在目录content/posts下新建一个Markdown文件my-first-post.md，其初始内容如下： --- title: \"My First Post\" date: 2020-05-09T22:51:33+08:00 draft: true --- 可以看到其中初始化了几个前置参数（Front Matter）。我们在后面加入一些内容，如This is my first post，然后重新启动服务：hugo server -D。需要注意的是这里需要加上选项-D，表示将Draft博文也显示在网站中。否则，新建的博文将不会显示，因为新建的博文的前置参数中draft默认为true。或者我们也可以将该draft参数修改为false。此时访问localhost:1313/，我们可以看到自己的博客已经显示出来： 加入一篇博文加入一篇博文 \"\r加入一篇博文\r ","date":"2020-05-09","objectID":"/posts/%E4%BD%BF%E7%94%A8hugo+github-pages%E6%9E%84%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/:4:0","tags":["Hugo","Github Pages"],"title":"使用Hugo+GitHub Pages构建博客网站","uri":"/posts/%E4%BD%BF%E7%94%A8hugo+github-pages%E6%9E%84%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"},{"categories":["博客搭建"],"content":"将网站部署到GitHub Pages上 首先，我们新建一个GitHub仓库blog-repo，用于存放前文所创建的所有网站文件。我们将其clone到本地，假设目录名也叫blog-repo，然后将前文中personal_blog目录下的所有文件和目录（.git除外）复制到blog-repo目录下。接下来，我们再新建一个GitHub仓库\u003cusername\u003e.github.io，用于存放Hugo最终生成的网站。这里的\u003cusername\u003e是你的GitHub用户名。然后，我们在blog-repo目录下执行以下命令： git submodule add -b master https://github.com/\u003cusername\u003e/\u003cusername\u003e.github.io.git public 上述命令会将\u003cusername\u003e.github.io仓库下载到blog-repo/public目录下。这个目录也是Hugo生成的网站默认所在的目录，所以后续生成网站之后，我们可以直接将blog-repo/public目录下的内容push到远端仓库中，这样就完成了网站在GitHub Pages上的部署。我们可以将部署过程写成一个shell script（参考自Hugo官方教程）: #!/bin/sh # If a command fails then the deploy stops set -e printf \"\\033[0;32mDeploying updates to GitHub...\\033[0m\\n\" # Build the project. hugo # if using a theme, replace with `hugo -t \u003cYOURTHEME\u003e` # Go To Public folder cd public # Add changes to git. git add . # Commit changes. msg=\"rebuilding site $(date)\" if [ -n \"$*\" ]; then msg=\"$*\" fi git commit -m \"$msg\" # Push source and build repos. git push origin master 这样每当我们撰写了新的博文，或者修改了网站设置，就可以执行上面的脚本将网站重新部署到GitHub Pages上。在Windows环境下，我们可以通过Git Bash或者Windows Subsystem for Linux来执行shell script。 ","date":"2020-05-09","objectID":"/posts/%E4%BD%BF%E7%94%A8hugo+github-pages%E6%9E%84%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/:5:0","tags":["Hugo","Github Pages"],"title":"使用Hugo+GitHub Pages构建博客网站","uri":"/posts/%E4%BD%BF%E7%94%A8hugo+github-pages%E6%9E%84%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"},{"categories":["博客搭建"],"content":"参考资料 https://gohugo.io/getting-started/quick-start/ https://gohugo.io/hosting-and-deployment/hosting-on-github/ https://hugoloveit.com/zh-cn/theme-documentation-basics/ https://hugoloveit.com/zh-cn/theme-documentation-content/ https://mjsmithdev.com/setting-up-hugo-on-windows/ ","date":"2020-05-09","objectID":"/posts/%E4%BD%BF%E7%94%A8hugo+github-pages%E6%9E%84%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/:6:0","tags":["Hugo","Github Pages"],"title":"使用Hugo+GitHub Pages构建博客网站","uri":"/posts/%E4%BD%BF%E7%94%A8hugo+github-pages%E6%9E%84%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"}]