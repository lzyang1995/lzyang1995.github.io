[{"categories":["前端开发"],"content":"最近实习期间在做一个基于Electron的开发调试工具，然后想利用node-pty以及xterm把terminal集成进来，就像VSCode里面的terminal一样，然后遇到了大坑。研究了很久才发现原来是使用默认导入（default import）的问题…… 原本我对于默认、非默认导入，以及不同的模块化的方式（CommonJS, ESM, AMD等）的关系，还有TypeScript的配置文件的认识都不是很深入。直到前几天，我和往常一样，用默认导入的方式引入node-pty： import os from 'os'; import pty from 'node-pty'; const shell = process.env[os.platform() === 'win32' ? 'COMSPEC' : 'SHELL']; const ptyProcess = pty.spawn(shell, [], { name: 'xterm-color', cols: 80, rows: 30, cwd: process.cwd(), env: process.env }); 结果报错： 导入node-pty出现错误导入node-pty出现错误 \"\r导入node-pty出现错误\r 意思就是我导入的pty是undefined。然后我就纳闷了，为什么会引入一个undefined？一开始以为是electron导入native module的问题，因为node-pty是一个navive module，而electron导入native module似乎很容易因为各种原因出问题，比如自己使用的Node版本和Electron中的Node版本不一致。然后以为是Webpack打包的问题，因为对于某些native module而言，打包会破坏原有的目录结构，如果native代码通过相对路径引用了JS代码，就会出现问题(https://github.com/JoshuaWise/better-sqlite3/issues/126#issuecomment-535459620)。所以我也尝试了在Webpack中将node-pty设置为external，然后利用copy-webpack-plugin把node_modules下的node-pty拷到Webpack输出目录的相应位置。然而这些都不是问题的关键。为了知道为什么会出现这个问题，我们需要先了解不同的模块化方式的关系以及TypeScript的相关配置。 ","date":"2020-08-18","objectID":"/posts/about-default-import-and-ts-config/:0:0","tags":["ESM","TypeScript"],"title":"关于ESM的default import以及TypeScript的坑","uri":"/posts/about-default-import-and-ts-config/"},{"categories":["前端开发"],"content":"通过ESM方式引入CommonJS模块 在使用Webpack的时候，我们一般使用ESM语法来引入模块。而被引入的模块一般都是CommonJS语法。此时，ESM的三种引入方式和CommonJS的引入方式存在下面的对应关系： import * as obj from 'module' \u003c===\u003e const obj = require('module'); import {a, b, c} from 'module' \u003c===\u003e const {a, b, c} = require('module'); import obj from 'module' \u003c===\u003e const obj = require('module').default; 可以看到，对于ESM的默认引入方式，会要求被引入的对象存在一个default属性。然而很多CommonJS模块输出的对象中可能都没有这个属性。对于这种情况，Babel会给输出的对象添加一个default属性，使得我们可以使用默认引入的方式。至于TypeScript，它提供了两个相关的配置项：esModuleInterop和allowSyntheticDefaultImports。 ","date":"2020-08-18","objectID":"/posts/about-default-import-and-ts-config/:1:0","tags":["ESM","TypeScript"],"title":"关于ESM的default import以及TypeScript的坑","uri":"/posts/about-default-import-and-ts-config/"},{"categories":["前端开发"],"content":"TypeScript配置中的esModuleInterop及allowSyntheticDefaultImports esModuleInterop也是为了解决ESM的默认引入的问题。在Webpack关于TypeScript的配置教程中(https://webpack.js.org/guides/typescript/)，有这样的描述： Webpack文档中关于这两个选项的描述Webpack文档中关于这两个选项的描述 \"\rWebpack文档中关于这两个选项的描述\r 当我们把esModuleInterop设置为true时，allowSyntheticDefaultImports也自动设置为true了。然而，设置这两项之后，使用default import就没有问题了吗？当然不是。我的项目出现错误的时候，这两项都已经被设置为true了。那么问题出在哪呢？我们可以先看esModuleInterop的不同设置下，TypeScript编译器输出的JS代码。TypeScript的文档(https://www.typescriptlang.org/tsconfig#esModuleInterop)提供了一个例子，对于下面的TypeScript代码： import * as fs from \"fs\"; import _ from \"lodash\"; fs.readFileSync(\"file.txt\", \"utf8\"); _.chunk([\"a\", \"b\", \"c\", \"d\"], 2); 当esModuleInterop为false时，输出如下： \"use strict\"; Object.defineProperty(exports, \"__esModule\", { value: true }); const fs = require(\"fs\"); const lodash_1 = require(\"lodash\"); fs.readFileSync(\"file.txt\", \"utf8\"); lodash_1.default.chunk([\"a\", \"b\", \"c\", \"d\"], 2); 当esModuleInterop为true时，输出如下： \"use strict\"; var __createBinding = (this \u0026\u0026 this.__createBinding) || (Object.create ? (function(o, m, k, k2) { if (k2 === undefined) k2 = k; Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } }); }) : (function(o, m, k, k2) { if (k2 === undefined) k2 = k; o[k2] = m[k]; })); var __setModuleDefault = (this \u0026\u0026 this.__setModuleDefault) || (Object.create ? (function(o, v) { Object.defineProperty(o, \"default\", { enumerable: true, value: v }); }) : function(o, v) { o[\"default\"] = v; }); var __importStar = (this \u0026\u0026 this.__importStar) || function (mod) { if (mod \u0026\u0026 mod.__esModule) return mod; var result = {}; if (mod != null) for (var k in mod) if (k !== \"default\" \u0026\u0026 Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k); __setModuleDefault(result, mod); return result; }; var __importDefault = (this \u0026\u0026 this.__importDefault) || function (mod) { return (mod \u0026\u0026 mod.__esModule) ? mod : { \"default\": mod }; }; Object.defineProperty(exports, \"__esModule\", { value: true }); const fs = __importStar(require(\"fs\")); const lodash_1 = __importDefault(require(\"lodash\")); fs.readFileSync(\"file.txt\", \"utf8\"); lodash_1.default.chunk([\"a\", \"b\", \"c\", \"d\"], 2); 可以看到，当esModuleInterop为false时，就是使用之前提到的方式来引入CommonJS模块。而当esModuleInterop为true时，TypeScript会提供一些helper function来辅助引入模块。 那么为什么使用ESM的默认方式引入node-pty会出问题？我们可以看一下note-pty模块的入口文件(lib/index.js)的代码： \"use strict\"; /** * Copyright (c) 2012-2015, Christopher Jeffrey, Peter Sunde (MIT License) * Copyright (c) 2016, Daniel Imms (MIT License). * Copyright (c) 2018, Microsoft Corporation (MIT License). */ Object.defineProperty(exports, \"__esModule\", { value: true }); var terminalCtor; if (process.platform === 'win32') { terminalCtor = require('./windowsTerminal').WindowsTerminal; } else { terminalCtor = require('./unixTerminal').UnixTerminal; } /** * Forks a process as a pseudoterminal. * @param file The file to launch. * @param args The file's arguments as argv (string[]) or in a pre-escaped * CommandLine format (string). Note that the CommandLine option is only * available on Windows and is expected to be escaped properly. * @param options The options of the terminal. * @throws When the file passed to spawn with does not exists. * @see CommandLineToArgvW https://msdn.microsoft.com/en-us/library/windows/desktop/bb776391(v=vs.85).aspx * @see Parsing C++ Comamnd-Line Arguments https://msdn.microsoft.com/en-us/library/17w5ykft.aspx * @see GetCommandLine https://msdn.microsoft.com/en-us/library/windows/desktop/ms683156.aspx */ function spawn(file, args, opt) { return new terminalCtor(file, args, opt); } exports.spawn = spawn; /** @deprecated */ function fork(file, args, opt) { return new terminalCtor(file, args, opt); } exports.fork = fork; /** @deprecated */ function createTerminal(file, args, opt) { return new terminalCtor(file, args, opt); } exports.createTerminal = createTerminal; function open(options) { return terminalCtor.open(options); } exports.open = open; /** * Expose the native API when not Windows, note that this is not public API and * could be rem","date":"2020-08-18","objectID":"/posts/about-default-import-and-ts-config/:2:0","tags":["ESM","TypeScript"],"title":"关于ESM的default import以及TypeScript的坑","uri":"/posts/about-default-import-and-ts-config/"},{"categories":["前端开发"],"content":"Electron中的app.allowRendererProcessReuse Electron目前默认不允许renderer process引入native module。而node-pty会引入.node模块，所以在renderer process中引入node-pty还是会报错。我们可以通过把app.allowRendererProcessReuse设置为false来解决这个问题，不过Electron不推荐这样做(https://github.com/electron/electron/issues/18397)。我们应该可以在main process中引入node-pty，然后通过ipc传给renderer process。 ","date":"2020-08-18","objectID":"/posts/about-default-import-and-ts-config/:3:0","tags":["ESM","TypeScript"],"title":"关于ESM的default import以及TypeScript的坑","uri":"/posts/about-default-import-and-ts-config/"},{"categories":["前端开发"],"content":"参考资料 https://github.com/JoshuaWise/better-sqlite3/issues/126#issuecomment-535459620 https://webpack.js.org/guides/typescript/ https://www.typescriptlang.org/tsconfig#esModuleInterop https://github.com/electron/electron/issues/18397 ","date":"2020-08-18","objectID":"/posts/about-default-import-and-ts-config/:4:0","tags":["ESM","TypeScript"],"title":"关于ESM的default import以及TypeScript的坑","uri":"/posts/about-default-import-and-ts-config/"},{"categories":["前端开发"],"content":"最近的实习项目需要基于Electron来做，如果能把Webpack, TypeScript和React也融入到开发过程中就再好不过了。这里记录一下搭建这样一个开发框架的过程。 搭建过程其实并不复杂，我是选择基于Electron Forge来做。Electron Forge已经提供了一个包含Webpack和TypeScript的模板（https://www.electronforge.io/templates/typescript-+-webpack-template），我们只需要再向里面加入React即可。 首先，使用如下命令初始化Electron Forge模板： npx create-electron-app my-new-app --template=typescript-webpack 在生成的项目目录中，src目录对应着源文件，其中index.ts是Electron main process的代码，在Webpack打包之后对应于.webpack\\main\\index.js。index.html是Electron renderer process加载的HTML文件，对应于.webpack\\renderer\\main_window\\index.html。renderer.ts对应于.webpack\\renderer\\main_window\\index.js，在Webpack打包之后会被index.html通过script标签引入。在项目目录中执行npm start就可以启动Electron程序。 接下来，我们需要安装React相关的依赖： npm install --save react react-dom npm install --save-dev @types/react @types/react-dom 为了能够使用JSX，我们需要在tsconfig.json的compilerOptions中加入\"jsx\": \"react\"。同时，使用JSX的源文件拓展名必须是.tsx而不能是.ts。 到这里开发的框架就已经搭建完成了。我们可以测试一下React的使用。首先，修改src\\index.html，加入一个div元素： index.htmlindex.html \"\rindex.html\r 然后将renderer.ts重命名为renderer.tsx，并修改如下： renderer.tsxrenderer.tsx \"\rrenderer.tsx\r 由于我们重命名了renderer文件，我们需要修改package.json中的相关配置： package.jsonpackage.json \"\rpackage.json\r 然后，执行npm start命令，可以看到如下结果： Electron程序界面Electron程序界面 \"\rElectron程序界面\r ","date":"2020-07-29","objectID":"/posts/electron-forge-with-react/:0:0","tags":["React","Electron"],"title":"搭建基于Webpack, TypeScript和React的Electron开发框架","uri":"/posts/electron-forge-with-react/"},{"categories":["前端开发"],"content":"参考资料 https://www.typescriptlang.org/docs/handbook/react-\u0026-webpack.html https://www.typescriptlang.org/docs/handbook/jsx.html#basic-usage https://ankitbko.github.io/2019/08/electron-forge-with-react-and-typescript/ https://www.electronforge.io/templates/typescript-+-webpack-template ","date":"2020-07-29","objectID":"/posts/electron-forge-with-react/:1:0","tags":["React","Electron"],"title":"搭建基于Webpack, TypeScript和React的Electron开发框架","uri":"/posts/electron-forge-with-react/"},{"categories":["前端开发"],"content":"VS Code是一个基于Electron的开源的代码编辑器。最近由于项目需要，要分析一下VS Code，因此打算先clone它的源码，然后构建运行起来。可能是因为我的网不好，再加上GFW的原因，这个过程异常艰难。因此在这里记录一下整个的构建过程。 首先我们按照官方教程，把各种必须的工具安装好，包括Git, NodeJS, Yarn, Python 2.7, 以及windows-build-tools，然后重启电脑。然后我们fork一下VSCode的repo并clone到本地。到这里都还比较顺利，接下来用Yarn安装依赖，问题就来了。 首先，我们需要一个FQ工具。然后使用如下命令设置一下yarn的proxy： yarn config set proxy http://localhost:XXXX yarn config set https-proxy http://localhost:XXXX 之后在vscode目录下执行命令yarn，会一直卡在第四步building fresh packages。这里我们需要先设置一下yarn的child-concurrency，把它设置成1： yarn config set child-concurrency 1 之后再执行yarn，会发现该命令是卡在了Electron的安装上。我先是尝试把.yarnrc文件中的disturl改成淘宝的镜像https://npm.taobao.org/mirrors/electron/，然而并没有用。从报错信息看，是在目录node_modules\\electron中执行node install.js出的问题。该脚本的内容如下： #!/usr/bin/env node const version = require('./package').version const fs = require('fs') const os = require('os') const path = require('path') const extract = require('extract-zip') const { downloadArtifact } = require('@electron/get') if (process.env.ELECTRON_SKIP_BINARY_DOWNLOAD) { process.exit(0) } const platformPath = getPlatformPath() if (isInstalled()) { process.exit(0) } // downloads if not cached downloadArtifact({ version, artifactName: 'electron', force: process.env.force_no_cache === 'true', cacheRoot: process.env.electron_config_cache, platform: process.env.npm_config_platform || process.platform, arch: process.env.npm_config_arch || process.arch }).then(extractFile).catch(err =\u003e { console.error(err.stack) process.exit(1) }) function isInstalled () { try { if (fs.readFileSync(path.join(__dirname, 'dist', 'version'), 'utf-8').replace(/^v/, '') !== version) { return false } if (fs.readFileSync(path.join(__dirname, 'path.txt'), 'utf-8') !== platformPath) { return false } } catch (ignored) { return false } const electronPath = process.env.ELECTRON_OVERRIDE_DIST_PATH || path.join(__dirname, 'dist', platformPath) return fs.existsSync(electronPath) } // unzips and makes path.txt point at the correct executable function extractFile (zipPath) { return new Promise((resolve, reject) =\u003e { extract(zipPath, { dir: path.join(__dirname, 'dist') }, err =\u003e { if (err) return reject(err) fs.writeFile(path.join(__dirname, 'path.txt'), platformPath, err =\u003e { if (err) return reject(err) resolve() }) }) }) } function getPlatformPath () { const platform = process.env.npm_config_platform || os.platform() switch (platform) { case 'mas': case 'darwin': return 'Electron.app/Contents/MacOS/Electron' case 'freebsd': case 'openbsd': case 'linux': return 'electron' case 'win32': return 'electron.exe' default: throw new Error('Electron builds are not available on platform: ' + platform) } } 该脚本的功能应该是通过downloadArtifact下载Electron压缩包，然后通过extractFile函数解压。如果设置了环境变量ELECTRON_SKIP_BINARY_DOWNLOAD，或者目录中已经存在解压后的Electron了，就不进行下载。因此，后面我参考了这篇文章的做法，手动从淘宝镜像https://npm.taobao.org/mirrors/electron/9.1.0/下载electron-v9.1.0-win32-x64.zip（我使用的win10 64位系统, vscode的.yarnrc中指定的Electron版本是9.1.0），并放到项目目录的node_modules\\electron中，重命名为electron.zip，并对install.js进行如下修改： #!/usr/bin/env node const version = require('./package').version const fs = require('fs') const os = require('os') const path = require('path') const extract = require('extract-zip') const { downloadArtifact } = require('@electron/get') if (process.env.ELECTRON_SKIP_BINARY_DOWNLOAD) { process.exit(0) } const platformPath = getPlatformPath() if (isInstalled()) { process.exit(0) } // downloads if not cached /*downloadArtifact({ version, artifactName: 'electron', force: process.env.force_no_cache === 'true', cacheRoot: process.env.electron_config_cache, platform: process.env.npm_config_platform || process.platform, arch: process.env.npm_config_arch || process.arch }).then(extractFile).catch(err =\u003e { console.error(err.stack) process.exit(1) })*/ extractFile(\"./electron.zip\").catch(err =\u003e { console.error(err.stack) process.exit(1) }) function isInstalled () { try { if (fs.readFileSync(path.join(__dirname, 'dist', 'version'), 'utf-8').replace(/^v/, '') !== version) { return false } if (fs.readFileSync(path.join(__dirname, 'p","date":"2020-07-22","objectID":"/posts/build-vscode/:0:0","tags":["Electron","VSCode"],"title":"从源码构建和运行VS Code","uri":"/posts/build-vscode/"},{"categories":["前端开发"],"content":"参考资料 https://github.com/Microsoft/vscode/wiki/How-to-Contribute https://stackoverflow.com/questions/51508364/yarn-there-appears-to-be-trouble-with-your-network-connection-retrying https://blog.csdn.net/qq_27005821/article/details/102748201 https://github.com/yarnpkg/yarn/issues/7450 ","date":"2020-07-22","objectID":"/posts/build-vscode/:1:0","tags":["Electron","VSCode"],"title":"从源码构建和运行VS Code","uri":"/posts/build-vscode/"},{"categories":["算法"],"content":"原题链接：https://leetcode.com/problems/copy-list-with-random-pointer/ 这道题要求对一个链表进行深拷贝，其中每个节点有一个额外的随机指针，随机指向链表中某一个节点或者NULL。之前在春招找实习的时候，被问了N次实现Javascript中的深拷贝，所以对这个也比较熟悉。方法就是通过递归来进行节点的复制，坑点在于链表中可能存在循环引用，因此单纯的递归会陷入死循环。解决方法是用一个Hashmap来保存从原链表的节点到新链表的节点的映射，如果我们现在要复制的节点已经在Hashmap中作为key存在了，那么就直接返回它对应的value，而不再创建新节点。代码实现如下： // Author: Zhiyang Li // Date: 2020.07.20 /* // Definition for a Node. class Node { public: int val; Node* next; Node* random; Node(int _val) { val = _val; next = NULL; random = NULL; } }; */ class Solution { private: Node * copy(Node *p, unordered_map\u003cNode *, Node *\u003e \u0026map) { if (p == nullptr) { return nullptr; } if (map.count(p) \u003e 0) { return map[p]; } Node *cur = new Node(p-\u003eval); map[p] = cur; cur-\u003enext = copy(p-\u003enext, map); cur-\u003erandom = copy(p-\u003erandom, map); return cur; } public: Node* copyRandomList(Node* head) { unordered_map\u003cNode *, Node *\u003e map; return copy(head, map); } }; 该算法的空间复杂度为$O(n)$，因为Hashmap中保存了$n$个节点的信息，时间复杂度也是$O(n)$，因为每个指针被访问了一次，而该链表中有$2n$个指针。 ","date":"2020-07-20","objectID":"/posts/leetcode138/:0:0","tags":["LeetCode","Algorithm"],"title":"Leetcode 138: Copy List with Random Pointer","uri":"/posts/leetcode138/"},{"categories":["前端开发"],"content":"最近自学了React，用Create React App脚手架做了一个小demo，然而Create React App毕竟是用来做单页应用的，可能不太适合做多页面的网站。并且即将去实习的单位是用Java做后台，因此就在想如何在开发过程中把React和Java Spring框架结合起来。这里我找到了一个教程：https://spring.io/guides/tutorials/react-and-spring-data-rest/，提供了很大的帮助，但是该教程在构建后台应用方面说的比较详细，在关键的如何在项目中引入前端框架方面却说的不太清楚。研究了一番之后大致清楚了具体做法和部分原理，在这里记录和分享一下。 教程的后台构建部分就不再描述了，这里重点关注前端部分。这里的关键是在maven项目中引入和使用一个maven插件（plugin），叫做frontend-maven-plugin。教程在pom.xml中插入了如下内容以引入该插件： \u003cplugin\u003e \u003cgroupId\u003ecom.github.eirslett\u003c/groupId\u003e \u003cartifactId\u003efrontend-maven-plugin\u003c/artifactId\u003e \u003c/plugin\u003e 然而这样是远远不够的。为了能够顺利地使用该插件，我们需要先知道maven的大致工作原理。 maven在我看来是一个Java的项目构建和包管理工具，类似于JavaScript的npm。我们可以使用它来创建项目，以及完成编译、测试、打包等项目生命周期中的各类操作。它把项目的生命周期（lifecycle）定义为了按顺序排列的各个阶段（phase），包括验证（validate）、编译（compile）、测试（test）、打包（package）等等，具体列表可以参考关于生命周期的文档。我们可以通过命令mvn加上生命周期中的任意阶段来执行从初始阶段到该阶段的所有阶段的操作。例如，如果我们执行mvn package，那么maven就会执行从验证到打包的所有操作，最终生成JAR（或者WAR、EAR，由项目配置决定）文件。 在maven项目中，项目配置文件叫做pom.xml，里面定义了项目相关的所有内容。其中一项就是项目所使用的插件，定义在\u003cplugins\u003e标签中。每个插件又包含多种功能，每个功能被称为goal，我们可以只执行插件中的某个或某几个goal。在生命周期的各个阶段，执行的实际上是各个插件的goals。其中在项目初始化时就已经包含了很多maven自带的插件的goals（可以在项目初始化时的pom.xml中看到，定义了很多插件）。对于我们自己加入的插件的goal，也可以在pom.xml中指定它在某个阶段运行。这样，当我们每次执行mvn命令时，只要覆盖了该阶段，这个插件的这个goal就会执行。 除此之外，我们也可以在命令行中单独执行插件的goal。命令的格式如下： mvn \u003cplugin-name\u003e:\u003cgoal\u003e -D\u003cparameter-name\u003e=\u003cvalue\u003e 其中\u003cplugin-name\u003e感觉一般就是pom.xml中插件的\u003cartifactId\u003e的前半部分，例如\u003cartifactId\u003e是spring-boot-maven-plugin那么\u003cplugin-name\u003e就是spring-boot。 明白了以上内容，我们就知道应该如何让前面的教程项目工作起来了。我们在pom.xml的frontend-maven-plugin部分加入如下内容： \u003cplugin\u003e \u003cgroupId\u003ecom.github.eirslett\u003c/groupId\u003e \u003cartifactId\u003efrontend-maven-plugin\u003c/artifactId\u003e \u003cversion\u003e1.10.0\u003c/version\u003e \u003cexecutions\u003e \u003cexecution\u003e \u003cid\u003einstall node and npm\u003c/id\u003e \u003cgoals\u003e \u003cgoal\u003einstall-node-and-npm\u003c/goal\u003e \u003c/goals\u003e \u003cconfiguration\u003e \u003c!-- See https://nodejs.org/en/download/ for latest node and npm (lts) versions --\u003e \u003cnodeVersion\u003ev12.18.0\u003c/nodeVersion\u003e \u003c/configuration\u003e \u003c/execution\u003e \u003cexecution\u003e \u003cid\u003enpm install\u003c/id\u003e \u003cgoals\u003e \u003cgoal\u003enpm\u003c/goal\u003e \u003c/goals\u003e \u003c/execution\u003e \u003cexecution\u003e \u003cid\u003ewebpack build\u003c/id\u003e \u003cgoals\u003e \u003cgoal\u003ewebpack\u003c/goal\u003e \u003c/goals\u003e \u003c/execution\u003e \u003c/executions\u003e \u003c/plugin\u003e 上面的xml中给这个插件定义了三个execution，每个execution对应着一个goal和一个生命周期的阶段（phase），这里我们使用这些goal的默认阶段（在该插件中定义为generate-resources），那么这三个goal就会在这个阶段自动执行。这里对于第一个goal我们加入了\u003cconfiguration\u003e标签进行配置，指定要安装的Node的版本。由于该版本自带npm，所以这里不用再指定npm的版本了。 接下来，我们只需要在命令行中执行spring-boot的命令： mvnw spring-boot:run 这里的mvnw是maven wrapper，对应着该项目专属的maven而不是系统的全局maven（详见此文章）。那么我们就可以看到，前面在pom.xml中定义的三个goal全部都执行了： 执行命令mvnw spring-boot:run执行命令mvnw spring-boot:run \"\r执行命令mvnw spring-boot:run\r 这里其实还有一个问题，就是我们实际运行的是插件spring-boot的一个goal，叫做run，为什么会把generate-resources阶段的三个frontend-maven-plugin的goal也执行了呢？我感觉原因是因为spring-boot的这个goal实际上就是运行到了生命周期的test-compile阶段： 输出中的test-compile输出中的test-compile \"\r输出中的test-compile\r 而该阶段在generate-resources之后，所以这三个goal也会执行。 现在前端模块已经打包并生成完毕了，如下图所示： webpack生成的文件webpack生成的文件 \"\rwebpack生成的文件\r 目录src/main/resources中的内容都会被打包。所以我们也可以在target目录中看到他们。现在我们可以正常访问网站根目录（index.html）了： index.html页面index.html页面 \"\rindex.html页面\r 当然，我们也可以不把frontend-maven-plugin的这三个goal放在pom.xml里面，而是在命令行中执行： 命令行执行前端插件命令行执行前端插件 \"\r命令行执行前端插件\r 不过这样我们每次修改前端代码之后都要在命令行中输入这些命令来编译前端内容，显然没有只执行一条命令mvnw spring-boot:run方便。 当然，该教程的例子中仍然只有一个网页。对于多个网页，我们可以给每个网页都在webpack中设置一个入口js文件（见https://webpack.js.org/concepts/entry-points/#multi-page-application），然后把生成的各个js文件分别插入到各个页面中即可。 ","date":"2020-06-15","objectID":"/posts/react%E4%B8%8Ejava-spring%E5%90%8E%E5%8F%B0%E8%81%94%E5%90%88%E5%BC%80%E5%8F%91/:0:0","tags":["React","Spring"],"title":"React与Java Spring后台联合开发","uri":"/posts/react%E4%B8%8Ejava-spring%E5%90%8E%E5%8F%B0%E8%81%94%E5%90%88%E5%BC%80%E5%8F%91/"},{"categories":["前端开发"],"content":"参考资料 https://spring.io/guides/tutorials/react-and-spring-data-rest/ https://github.com/eirslett/frontend-maven-plugin https://maven.apache.org/guides/getting-started/index.html https://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html https://maven.apache.org/guides/getting-started/maven-in-five-minutes.html https://maven.apache.org/guides/mini/guide-configuring-plugins.html https://www.liaoxuefeng.com/wiki/1252599548343744/1305148057976866 https://webpack.js.org/concepts/entry-points/#multi-page-application ","date":"2020-06-15","objectID":"/posts/react%E4%B8%8Ejava-spring%E5%90%8E%E5%8F%B0%E8%81%94%E5%90%88%E5%BC%80%E5%8F%91/:1:0","tags":["React","Spring"],"title":"React与Java Spring后台联合开发","uri":"/posts/react%E4%B8%8Ejava-spring%E5%90%8E%E5%8F%B0%E8%81%94%E5%90%88%E5%BC%80%E5%8F%91/"},{"categories":["GitHub"],"content":"最近自学了一下React，Redux以及React Router的相关内容，想找个项目练练手，于是找到了B站上的一个教程（https://www.bilibili.com/video/BV1T7411W72T），这个教程最后有一个仿百万英雄的答题App的小项目，然后就按照它的功能自己实现了一遍。今天想着把这个项目上传到GitHub上，顺便学习一下自己还不太熟悉的Git。这里记录一下自己的上传过程。 首先进入我们的项目目录，使用如下命令初始化本地仓库： git init 该命令会在项目目录中建立一个.git目录。不过实际上在Create React App创建的项目目录中已经存在.git目录了。 此时项目目录中的所有文件都处于untracked状态。接下来使用如下命令让Git来track目录中的所有文件： git add * 这个命令同时会stage所有的文件，让它们处于可以commit的状态。注意.gitignore文件中指定的文件不会被track。 技巧\r\r当我们发现自己通过add命令加入了一个不应该加入的文件时，此时更新.gitignore文件是没有用的，因为.gitignore只能让untracked文件保持 untracked，并不能把tracked文件变回untracked。假设我们想移除的文件是a.txt，那么我们需要执行如下命令： git rm --cached a.txt 这里的--cached选项是为了让a.txt仍然存在于项目目录中，只是变成untracked文件，否则a.txt会被删除。之后我们需要执行commit命令来将 这个改变记录在快照（snapshot）中。 \r\r 接下来就可以使用commit命令保存当前的快照（snapshot）： git commit -m \"message\" 现在我们还没有指定要把这个项目上传到哪个远程仓库。这里我们登录GitHub新建一个仓库，如下图所示，URL为https://github.com/lzyang1995/Millionare-Hero.git: 创建仓库创建仓库 \"\r创建仓库\r 这里由于我已经创建过这个仓库了，所以图中显示的是已经存在。这里我选择初始化时加入一个README和Licence，实际上什么都不加的话后续会方便一点。 现在我们就可以在本地添加对应的远程仓库的信息了。执行如下命令来添加远程仓库： git remote add origin https://github.com/lzyang1995/Millionare-Hero.git 这里我们把这个远程仓库命名为了origin。接下来我们执行fetch命令来获取远程仓库的branch信息： git fetch origin 然后我们可以设置一下本地的master branch的upstream branch，把它设置成远程仓库的master branch，即origin/master: git branch -u origin/master 我们可以通过git branch -vv命令来查看upstream branch的设置情况。接下来我们把origin/master来merge进我们本地的master branch： git merge origin/master --allow-unrelated-histories 注意这个地方我们必须加上--allow-unrelated-histories，因为本地的master branch和origin/master没有共同的父节点，默认是不允许merge的。 这里在merge的时候出现了一个小问题，就是我远程新建仓库是初始化了一个README，结果本地项目目录中也有一个README（Create React App生成的），所以出现了merge conflict。解决方法就是自行修改README，保存后执行add和commit命令： git add README.md git commit -m \"Merge the projects\" 这样merge conflict就解决了。现在我们可以把我们的项目上传到远程仓库了，执行如下命令： git push origin master 这个命令是git push origin master:master的缩写，作用是把本地的master branch上传到origin/master branch。 到这里，项目就已经上传完成了。不过，后续我把项目clone到本地，执行npm install，然后执行npm start试着运行的时候，会报编译错误，说无法找到某某模块，而这些模块实际上在原项目中已经安装过了。后来发现问题可能出在cnpm上，原项目的这些模块是通过cnpm安装的，我后面又在原项目中用npm把这些模块重新安装了一遍，再次push到远程仓库，然后clone到本地试运行，就没有再报错了。 ","date":"2020-06-12","objectID":"/posts/%E4%BD%BF%E7%94%A8git%E5%B0%86%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/:0:0","tags":["Git"],"title":"使用Git将本地项目上传到远程仓库","uri":"/posts/%E4%BD%BF%E7%94%A8git%E5%B0%86%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"},{"categories":["GitHub"],"content":"参考资料 https://git-scm.com/book/en/v2 ","date":"2020-06-12","objectID":"/posts/%E4%BD%BF%E7%94%A8git%E5%B0%86%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/:1:0","tags":["Git"],"title":"使用Git将本地项目上传到远程仓库","uri":"/posts/%E4%BD%BF%E7%94%A8git%E5%B0%86%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"},{"categories":["算法"],"content":"原题链接：https://leetcode.com/problems/longest-consecutive-sequence/ 这道题要求我们在$O(n)$的时间内找出一个无序数组中最长的连续数字的长度。这道题我也没有做出来，这里介绍一下Discuss板块中其他人分享的一个解法（https://leetcode.com/problems/longest-consecutive-sequence/discuss/41057/Simple-O(n)-with-Explanation-Just-walk-each-streak）：首先把输入数组nums中的所有数都放入一个集合（set）中，然后再把nums遍历一次。遍历到某个数$n$时，如果$n-1$也在集合中，说明$n$不是某一段连续数字的开头，因此直接跳过这个数访问下一个。如果$n-1$不在集合中，说明$n$是某一段连续数字的开头，那么我们就进一步去判断$n+1, n+2, n+3, \\cdots$等等是否在集合中，直到到达某个数$m$不在这个集合中，那么这段连续数字的长度就是$m-n$。我们只需要在遍历过程中保存$m-n$的最大值即可。 关于这个算法的时间复杂度，首先第一步将所有数都放入集合的时间复杂度是$O(n)$。对于后续的遍历，如果$n$不是某一段连续数字的开头，我们只会访问$n$和$n-1$各一次，否则我们会访问从$n$到$m$的所有数各一次，最终每个数最多被访问3次（被作为$n$访问、被作为$n-1$访问、被作为$n$到$m$中的数访问），所以时间复杂度仍然是$O(n)$。因此该算法总的时间复杂度是$O(n)$。 下面是我参考该思路的代码实现： // Author: Zhiyang Li // Date: 2020.05.26 class Solution { public: int longestConsecutive(vector\u003cint\u003e\u0026 nums) { unordered_set\u003cint\u003e set; int result = 0; for (int i = 0;i \u003c nums.size();i++) { set.insert(nums[i]); } for (int i = 0;i \u003c nums.size();i++) { int curNum = nums[i]; if (set.count(curNum - 1) == 0) { int tail = curNum + 1; while (set.count(tail) != 0) { tail++; } if (tail - curNum \u003e result) { result = tail - curNum; } } } return result; } }; ","date":"2020-05-26","objectID":"/posts/leetcode128/:0:0","tags":["LeetCode","Algorithm"],"title":"LeetCode 128: Longest Consecutive Sequence","uri":"/posts/leetcode128/"},{"categories":["算法"],"content":"参考资料 https://leetcode.com/problems/longest-consecutive-sequence/discuss/41057/Simple-O(n)-with-Explanation-Just-walk-each-streak ","date":"2020-05-26","objectID":"/posts/leetcode128/:1:0","tags":["LeetCode","Algorithm"],"title":"LeetCode 128: Longest Consecutive Sequence","uri":"/posts/leetcode128/"},{"categories":["算法"],"content":"原题链接：https://leetcode.com/problems/binary-tree-maximum-path-sum/ 这道题是要在一棵二叉树中寻找一条路径，使得该路径上的节点的和（Path Sum）最大。这里的路径是图论中的路径，即可以从任意一点开始到任意一点结束，而不是通常见到的从根节点开始的路径。 在二叉树里面，Path Sum最大的路径必然包含一个高度最高的节点（即最接近根节点的那个节点），该路径以该节点为中心，分别向该节点的左子树和右子树延伸。因此，我们只需要对于树中的每个节点，都计算一下以该节点为最高节点的Path Sum的最大值，这些最大值中的最大值就是最终的结果（即该二叉树的最大Path Sum）。为此，我们可以定义一个递归函数recur(node)，去计算以node为最高节点并且只向一边延伸（左子树或者右子树）的Path Sum的最大值，这个值可以根据recur(node.left)和recur(node.right)来计算。与此同时，以node为最高节点的Path Sum的最大值（不限制延伸的方向）也可以根据recur(node.left)和recur(node.right)计算出来。具体代码如下： // Author: Zhiyang Li // Date: 2020.05.22 /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {number} */ // 返回以node为最高节点，并且只向一边延伸的Path Sum的最大值。 // result用于存放最终结果 function recur(node, result) { if (node === null) return 0; let l1 = recur(node.left, result); let r1 = recur(node.right, result); let cur1 = Math.max(l1, r1, 0); let cur1l = Math.max(l1, 0); let cur1r = Math.max(r1, 0); // 计算以node为最高节点的Path Sum的最大值，如果大于result.value // 就更新result.value if (node.val + cur1l + cur1r \u003e result.value) { result.value = node.val + cur1l + cur1r; } return node.val + cur1; } var maxPathSum = function(root) { let result = {value: -Infinity}; recur(root, result); return result.value; }; 由于该算法只访问了每个节点1次，因此时间复杂度为$O(n)$。 ","date":"2020-05-22","objectID":"/posts/leetcode124/:0:0","tags":["LeetCode","Algorithm"],"title":"LeetCode 124: Binary Tree Maximum Path Sum","uri":"/posts/leetcode124/"},{"categories":["算法"],"content":"原题链接：https://leetcode.com/problems/flatten-binary-tree-to-linked-list/ 这道题的题意是要实现一个flatten函数，把一棵二叉树按照先序遍历的顺序变成一个单链表。看到二叉树就想到递归，这道题也是可以通过递归来做的。我们要flatten一棵树，实际上就是把它的左子树和右子树都进行flatten操作，然后把左子树flatten的结果接到根节点上，右子树flatten的结果接到左子树flatten之后的最后一个节点上。下面的代码就是基于这个思路： // Author: Zhiyang Li // Date: 2020.05.19 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: void flatten(TreeNode* root) { if (root == nullptr) return; TreeNode *l = root-\u003eleft; TreeNode *r = root-\u003eright; root-\u003eleft = nullptr; root-\u003eright = l; flatten(l); flatten(r); TreeNode *p = root; while (p-\u003eright != nullptr) { p = p-\u003eright; } p-\u003eright = r; } }; 然而，上面的算法效率并不是很高，主要问题在于需要寻找左子树flatten的结果的最后一个节点。这个操作会把左子树的所有节点都访问一次，导致在递归过程中，有很多节点被重复访问了很多次，越往左下角访问的次数越多。 论坛中有人提出了另一种递归的算法。这个算法不是很好理解，不过它的大致思路是按照先序遍历的逆序来构造单链表。先序遍历的访问顺序是根节点-左子树-右子树，因此该算法是按照右子树-左子树-根节点的顺序来进行访问和单链表构造的。这也是一个比较常用的思路。例如，对一棵二叉树进行后序遍历时，如果要求不使用递归，那么一个比较简单的方法是按照后序遍历的逆序，即根节点-右子树-左子树来进行遍历，再把结果倒过来。这个的话用一个栈就可以轻松做到。 论坛中还有另一个不使用递归的算法。该算法的思路是，对于当前访问的节点N，找到N的左子树的最右端的节点X，然后把X的right指针指向N的右子树。即相当于把N的右子树进行移动，成为X的右子树。这样操作前后，以N为根的子树的先序遍历的结果是不变的。所以我们可以继续只对N的左子树进行下一步的同样的操作，直到把所有的节点都遍历完。这个思路类似于Morris Traversal，时间复杂度应该是$O(n)$。 ","date":"2020-05-19","objectID":"/posts/leetcode114/:0:0","tags":["LeetCode","Algorithm"],"title":"LeetCode 114: Flatten Binary Tree to Linked List","uri":"/posts/leetcode114/"},{"categories":["算法"],"content":"参考资料 https://leetcode.com/problems/flatten-binary-tree-to-linked-list/discuss/36977/My-short-post-order-traversal-Java-solution-for-share https://leetcode.com/problems/flatten-binary-tree-to-linked-list/discuss/37010/Share-my-simple-NON-recursive-solution-O(1)-space-complexity! ","date":"2020-05-19","objectID":"/posts/leetcode114/:1:0","tags":["LeetCode","Algorithm"],"title":"LeetCode 114: Flatten Binary Tree to Linked List","uri":"/posts/leetcode114/"},{"categories":["算法"],"content":"原题链接：https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/ 这道题要求根据一棵二叉树的先序遍历（Preorder）和中序遍历（Inorder）的结果重建这棵树。首先，我们知道，先序遍历是按照根节点-左子树-右子树的顺序遍历的，而中序遍历是按照左子树-根节点-右子树的顺序遍历的。所以，一棵树的先序遍历和中序遍历的结果实际上具有以下结构： 遍历结果的结构遍历结果的结构 \"\r遍历结果的结构\r 看到这里，我们应该就清楚这道题应该用递归来做了。递归过程中，对于某棵子树的先序和中序遍历结果，先序遍历结果的第一个值（不妨称为x）是该子树的根节点，然后我们在中序遍历结果中去寻找x，x的左边就是该子树的左子树的中序遍历结果，右边就是该子树的右子树的中序遍历结果。知道了左子树的中序遍历结果，也就知道了左子树的节点数，这样再回到先序遍历结果，我们就知道左子树以及右子树的先序遍历结果了。然后对于左子树和右子树分别进行递归即可。具体代码如下： // Author: Zhiyang Li // Date: 2020.05.18 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* buildTree(vector\u003cint\u003e\u0026 preorder, vector\u003cint\u003e\u0026 inorder) { if (preorder.size() == 0 \u0026\u0026 inorder.size() == 0) return nullptr; int rootVal = preorder[0]; TreeNode *root = new TreeNode(rootVal); int rootInd; for (int i = 0;i \u003c inorder.size();i++) { if (inorder[i] == rootVal) { rootInd = i; break; } } vector\u003cint\u003e leftPre(preorder.begin() + 1, preorder.begin() + 1 + rootInd); vector\u003cint\u003e leftIn(inorder.begin(), inorder.begin() + rootInd); vector\u003cint\u003e rightPre(preorder.begin() + 1 + rootInd, preorder.end()); vector\u003cint\u003e rightIn(inorder.begin() + rootInd + 1, inorder.end()); TreeNode *left = buildTree(leftPre, leftIn); TreeNode *right = buildTree(rightPre, rightIn); root-\u003eleft = left; root-\u003eright = right; return root; } }; 对于平衡二叉树，该算法的时间复杂度是$O(nlogn)$（可以按照$T(n) = 2T(\\frac{n}{2}) + O(n)$计算）。这里我们在每一次递归过程中都需要$O(n)$的时间来寻找根节点在中序遍历结果中的位置。实际上，我们可以在一开始就利用一个Hash Map来存储每个节点在中序遍历结果中的位置，后面递归时只需要在这个Hash Map中查找即可，时间复杂度为$O(1)$，这样就把整个算法的时间复杂度降低到了$O(n)$（可以按照$T(n) = 2T(\\frac{n}{2}) + O(1)$计算）。修改后的具体代码如下： // Author: Zhiyang Li // Date: 2020.05.18 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { private: TreeNode * recur(vector\u003cint\u003e\u0026 preorder, vector\u003cint\u003e\u0026 inorder, unordered_map\u003cint, int\u003e \u0026map, int preBegin, int preEnd, int inBegin, int inEnd) { if (preBegin == preEnd \u0026\u0026 inBegin == inEnd) return nullptr; int rootVal = preorder[preBegin]; TreeNode *root = new TreeNode(rootVal); int rootInd = map[rootVal]; int numLeft = rootInd - inBegin; TreeNode *left = recur(preorder, inorder, map, preBegin + 1, preBegin + 1 + numLeft, inBegin, rootInd); TreeNode *right = recur(preorder, inorder, map, preBegin + 1 + numLeft, preEnd, rootInd + 1, inEnd); root-\u003eleft = left; root-\u003eright = right; return root; } public: TreeNode* buildTree(vector\u003cint\u003e\u0026 preorder, vector\u003cint\u003e\u0026 inorder) { unordered_map\u003cint, int\u003e map; for (int i = 0;i \u003c inorder.size();i++) { map[inorder[i]] = i; } int n = preorder.size(); return recur(preorder, inorder, map, 0, n, 0, n); } }; 论坛中还有人提到说不用Hash Map也可以在$O(n)$时间内实现这个算法（https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/discuss/34543/Simple-O(n)-without-map），这个有空再来分析一下。 ","date":"2020-05-18","objectID":"/posts/leetcode105/:0:0","tags":["LeetCode","Algorithm"],"title":"LeetCode 105: Construct Binary Tree from Preorder and Inorder Traversal","uri":"/posts/leetcode105/"},{"categories":["JavaScript"],"content":"JavaScript引擎是基于Event Loop来运行的，不断处理队列中的各项任务。Event Loop包含一个调用栈（Stack），若干个任务队列（Queue）和一个堆（Heap）。它的工作模式就是不断从任务队列中取出任务放入栈中执行，一次只执行一个任务，当前任务执行完之后再从任务队列中取出下一个任务开始执行。当我们把Promise以及async/await也考虑进Event Loop时，各项任务的执行顺序就变得稍显复杂。 这里谈谈我在查阅一些资料之后对于它们的理解。 ","date":"2020-05-14","objectID":"/posts/%E6%B5%85%E6%9E%90promiseasync+await%E4%B8%8Eevent-loop/:0:0","tags":["JavaScript","Promise","Event Loop"],"title":"浅析Promise、async/await与Event Loop","uri":"/posts/%E6%B5%85%E6%9E%90promiseasync+await%E4%B8%8Eevent-loop/"},{"categories":["JavaScript"],"content":"宏任务（Macrotask） 在Event Loop中，其中一个任务队列被称为宏任务队列（Macrotask Queue），用于存放各种宏任务。属于宏任务的主要有以下几种： JS脚本 setTimeout、setInterval中的callback函数 用于处理各种事件（如click、mousemove）的handler函数 一个比较经典的关于Event Loop和宏任务的问题就是setTimeout中的callback的执行顺序问题。例如下面的代码： console.log(0); setTimeout(() =\u003e console.log(1), 0); console.log(2); 该代码的输出顺序应该是0, 2, 1。这里虽然setTimeout的第二个参数被设置为0，但其中的callback仍然在console.log(2)之后执行，因为当前栈中的任务是上面的脚本，setTimeout中的callback是被放入了宏任务队列中，只有在上面的脚本执行结束之后，这个callback才会被放入栈中执行。具体的执行步骤如下： 上述脚本被放入栈中 执行console.log(0)，输出0 执行setTimeout，开启一个线程用于计时。由于延时被设置为0，因此计时立刻结束，callback被放入宏任务队列中 执行console.log(2)，输出2 脚本执行完毕，callback被放入栈中开始执行，输出1 ","date":"2020-05-14","objectID":"/posts/%E6%B5%85%E6%9E%90promiseasync+await%E4%B8%8Eevent-loop/:1:0","tags":["JavaScript","Promise","Event Loop"],"title":"浅析Promise、async/await与Event Loop","uri":"/posts/%E6%B5%85%E6%9E%90promiseasync+await%E4%B8%8Eevent-loop/"},{"categories":["JavaScript"],"content":"Promise与Event Loop 对于Promise，首先其构造函数中的参数（function (resolve, reject) {}）是同步执行的，即在构造Promise时会立即执行，执行完毕后才会返回构造好的Promise对象。另外，在Promise settle之后，then/catch/finally中的handler函数会被放入另一个任务队列，称为微任务队列（Microtask Queue）。JS引擎在执行完当前的宏任务之后，会先把微任务队列中的所有任务都执行完毕（包括执行过程中新加入的微任务），再去执行宏任务队列中的下一个宏任务。除了Promise的handler函数之外，我们还可以通过queueMicrotask将一个函数放入微任务队列中。 对于下面的例子： console.log(0); Promise.resolve().then(() =\u003e console.log(1)).then(() =\u003e console.log(2)); setTimeout(() =\u003e console.log(3), 0); console.log(4); 上述代码的输出为0, 4, 1, 2, 3。具体的步骤如下： 上述脚本被放入栈中 执行console.log(0)，输出0 Promise.resolve()返回一个fulfilled promise，因此函数() =\u003e console.log(1)被放入微任务队列中 执行setTimeout，函数() =\u003e console.log(3)被放入宏任务队列中 执行console.log(4)，输出4，上述脚本执行完毕 从微任务队列中取出函数() =\u003e console.log(1)并执行，输出1。该函数相当于返回一个fulfilled promise，因此() =\u003e console.log(2)又被 放入微任务队列中 从微任务队列中取出函数() =\u003e console.log(2)并执行，输出2 微任务队列已经清空，从宏任务队列中取出函数() =\u003e console.log(3)并执行，输出3 我们再来看一个例子： console.log(0); new Promise(function(resolve, reject) { console.log(1); setTimeout(() =\u003e console.log(2), 0); resolve(); }).then(() =\u003e console.log(3)); console.log(4); 这个代码的输出将会是0, 1, 4, 3, 2。具体步骤如下： 上述脚本被放入栈中 执行console.log(0)，输出0 执行Promise构造函数中的内容。首先执行console.log(1)，输出1；然后执行setTimeout，将() =\u003e console.log(2)放入宏任务队列中； 最后执行resolve，使得该promise变成一个fulfilled promise。 由于promise已经fulfilled，函数() =\u003e console.log(3)被放入微任务队列中 执行console.log(4)，输出4，上述脚本执行完毕 从微任务队列中取出函数() =\u003e console.log(3)并执行，输出3 微任务队列已经清空，从宏任务队列中取出函数() =\u003e console.log(2)并执行，输出2 ","date":"2020-05-14","objectID":"/posts/%E6%B5%85%E6%9E%90promiseasync+await%E4%B8%8Eevent-loop/:2:0","tags":["JavaScript","Promise","Event Loop"],"title":"浅析Promise、async/await与Event Loop","uri":"/posts/%E6%B5%85%E6%9E%90promiseasync+await%E4%B8%8Eevent-loop/"},{"categories":["JavaScript"],"content":"async/await与Event Loop async/await被称作是Promise的语法糖，所以要分析包含async/await的代码的执行顺序，我们需要理解async/await内部是如何通过Promise来实现的。下面谈谈我在查阅一些资料后的个人理解。 对于下面的async函数的伪代码： async function func() { doSomething(); let result = await A; processResult(result); } 实际上await后面的内容相当于Promise A的handler函数。也就是说，上面的代码等价于： async function func() { doSomething(); A.then((result) =\u003e { processResult(result); }); } 因此，当我们的调用栈进入async函数内部，遇到await之后，会把await右边的Promise中的同步内容执行完，然后退出该async函数去执行该函数后面的同步内容。如果await右侧的Promise resolve了，那么该async函数剩下的部分会被放入微任务队列中。 例如，对于下面的代码： async function func1() { console.log(1); await func2(); console.log(2); } async function func2() { console.log(3); } console.log(0); func1().then(() =\u003e console.log(4)); setTimeout(() =\u003e console.log(5), 0) console.log(6); 其输出顺序将会是0, 1, 3, 6, 2, 4, 5。具体分析如下： 上述脚本被放入栈中 执行console.log(0)，输出0 进入func1函数，执行console.log(1)，输出1 进入func2函数，执行console.log(3)，输出3，并返回一个fulfilled promise（值为undefined）。func1函数await后面的部分被放入微任务队列中。 执行setTimeout，将函数() =\u003e console.log(5)放入宏任务队列中 执行console.log(6)，输出6。脚本结束，调用栈清空 从微任务队列中取出func1函数await后面的部分开始执行，输出2。由于func1返回了一个fulfilled promise（值为undefined），因此函数() =\u003e console.log(4)被放入微任务队列中 从微任务队列中取出函数() =\u003e console.log(4)执行，输出4 微任务队列为空，从宏任务队列中取出() =\u003e console.log(5)并执行，输出5 ","date":"2020-05-14","objectID":"/posts/%E6%B5%85%E6%9E%90promiseasync+await%E4%B8%8Eevent-loop/:3:0","tags":["JavaScript","Promise","Event Loop"],"title":"浅析Promise、async/await与Event Loop","uri":"/posts/%E6%B5%85%E6%9E%90promiseasync+await%E4%B8%8Eevent-loop/"},{"categories":["JavaScript"],"content":"参考资料 https://segmentfault.com/a/1190000017554062 https://juejin.im/post/5c148ec8e51d4576e83fd836 https://www.cnblogs.com/beyondcheng/p/3440154.html https://juejin.im/post/5c9a43175188252d876e5903 https://javascript.info/microtask-queue https://javascript.info/event-loop ","date":"2020-05-14","objectID":"/posts/%E6%B5%85%E6%9E%90promiseasync+await%E4%B8%8Eevent-loop/:4:0","tags":["JavaScript","Promise","Event Loop"],"title":"浅析Promise、async/await与Event Loop","uri":"/posts/%E6%B5%85%E6%9E%90promiseasync+await%E4%B8%8Eevent-loop/"},{"categories":["博客搭建"],"content":"Hugo是一个基于Go语言的静态网站构建工具，它提供了大量可供选择的模板主题（Theme），帮助我们更加快捷地搭建自己的网站，并且可以非常方便地部署在GitHub Pages上。 下面分享一下我利用Hugo和Github Pages搭建博客网站（也就是这个网站）的一些经验。 ","date":"2020-05-09","objectID":"/posts/%E4%BD%BF%E7%94%A8hugo+github-pages%E6%9E%84%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/:0:0","tags":["Hugo","GitHub Pages"],"title":"使用Hugo+GitHub Pages构建博客网站","uri":"/posts/%E4%BD%BF%E7%94%A8hugo+github-pages%E6%9E%84%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"},{"categories":["博客搭建"],"content":"Hugo安装 Hugo支持各种主流操作系统。对于Windows系统，我们可以直接使用预先编译好的可执行文件（https://github.com/gohugoio/hugo/releases）。Windows下的可执行文件有两个版本，一个是常规版本，另一个是扩展版本（extended），这两个版本的区别在于后者支持Sass，而前者不支持，所以如果后面选择的模板主题中使用了Sass，就必须下载扩展版本。 下载完成之后，我们可以把Hugo可执行文件添加到环境变量Path中，方便在命令行中调用。 ","date":"2020-05-09","objectID":"/posts/%E4%BD%BF%E7%94%A8hugo+github-pages%E6%9E%84%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/:1:0","tags":["Hugo","GitHub Pages"],"title":"使用Hugo+GitHub Pages构建博客网站","uri":"/posts/%E4%BD%BF%E7%94%A8hugo+github-pages%E6%9E%84%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"},{"categories":["博客搭建"],"content":"网站构建 首先在命令行中执行hugo new site personal_blog，这会在当前目录下新建一个名为personal_blog的目录，并在该目录下生成一些初始文件及目录： 初始文件及目录初始文件及目录 \"\r初始文件及目录\r 其中一些文件及目录的作用如下： config.toml: 网站的配置文件，可以用于设置网站的标题、语言、使用的模板主题、作者信息等等，具体选项可以参考各个模板主题的文档 themes: 用于存放模板主题相关的文件 static: 可用于存放网站用到的图像、视频、音乐等资源 content: 用于存放Markdown文件，如撰写的博客文档 接下来我们可以前往https://themes.gohugo.io/选择一个喜欢的模板主题。里面有非常非常多的主题可供选择： 主题主题 \"\r主题\r 这里以主题LoveIt为例进行说明。首先我们进入personal_blog目录，然后在命令行中执行以下命令将该主题下载到themes目录中： git init git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt 然后在配置文件中加入如下内容，指定使用的主题和版本（注意不要删去原有内容）： theme = \"LoveIt\" [params] version = \"0.2.X\" 这样基本的网站框架就搭建好了。我们可以在本地启动服务查看网站的效果，方法是在命令行中输入hugo server，然后访问网址localhost:1313/。大致的效果如下： 网站框架网站框架 \"\r网站框架\r ","date":"2020-05-09","objectID":"/posts/%E4%BD%BF%E7%94%A8hugo+github-pages%E6%9E%84%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/:2:0","tags":["Hugo","GitHub Pages"],"title":"使用Hugo+GitHub Pages构建博客网站","uri":"/posts/%E4%BD%BF%E7%94%A8hugo+github-pages%E6%9E%84%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"},{"categories":["博客搭建"],"content":"网站配置 刚才我们看到的网站非常简陋，因此接下来我们需要对网站进行配置以丰富网站的内容，方法是对配置文件config.toml进行修改。不同的模板主题支持的参数可能不太一样，我们选择的主题LoveIt所支持的各种参数和功能可以参考其文档。下面是一个比较简单的配置文件的例子，主要设置了语言、标题、主题、主题版本、搜索、菜单栏、作者等。 baseURL = \"http://example.org/\" # [en, zh-cn, fr, ...] 设置默认的语言 defaultContentLanguage = \"zh-cn\" # 网站语言, 仅在这里 CN 大写 languageCode = \"zh-CN\" # 是否包括中日韩文字 hasCJKLanguage = true # 网站标题 title = \"志洋的博客\" # 更改使用 Hugo 构建网站时使用的默认主题 theme = \"LoveIt\" [params] # LoveIt 主题版本 version = \"0.2.X\" defaultTheme = \"dark\" [params.search] enable = true # type of search engine (\"lunr\", \"algolia\") type = \"lunr\" # max index length of the chunked content contentLength = 4000 # placeholder of the search bar placeholder = \"\" # LoveIt NEW | 0.2.1 max number of results length maxResultLength = 10 # LoveIt NEW | 0.2.3 snippet length of the result snippetLength = 30 # LoveIt NEW | 0.2.1 HTML tag name of the highlight part in results highlightTag = \"em\" # LoveIt NEW | 0.2.4 whether to use the absolute URL based on the baseURL in search index absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" [menu] [[menu.main]] identifier = \"posts\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" name = \"文章\" url = \"/posts/\" # 当你将鼠标悬停在此菜单链接上时, 将显示的标题 title = \"\" weight = 1 [[menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" weight = 2 [[menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" weight = 3 [[menu.main]] identifier = \"github\" pre = \"\u003ci class='fab fa-github fa-fw'\u003e\u003c/i\u003e\" post = \"\" name = \"\" url = \"https://github.com/lzyang1995\" title = \"GitHub\" weight = 4 [outputs] home = [\"HTML\", \"RSS\", \"JSON\"] [author] name = \"李志洋\" 设置修改完成后，网站的大致效果如下： 修改设置后的效果修改设置后的效果 \"\r修改设置后的效果\r ","date":"2020-05-09","objectID":"/posts/%E4%BD%BF%E7%94%A8hugo+github-pages%E6%9E%84%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/:3:0","tags":["Hugo","GitHub Pages"],"title":"使用Hugo+GitHub Pages构建博客网站","uri":"/posts/%E4%BD%BF%E7%94%A8hugo+github-pages%E6%9E%84%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"},{"categories":["博客搭建"],"content":"撰写博客 我们可以通过hugo new命令来新建一篇博文，如hugo new posts/my-first-post.md，这样会在目录content/posts下新建一个Markdown文件my-first-post.md，其初始内容如下： --- title: \"My First Post\" date: 2020-05-09T22:51:33+08:00 draft: true --- 可以看到其中初始化了几个前置参数（Front Matter）。我们在后面加入一些内容，如This is my first post，然后重新启动服务：hugo server -D。需要注意的是这里需要加上选项-D，表示将Draft博文也显示在网站中。否则，新建的博文将不会显示，因为新建的博文的前置参数中draft默认为true。或者我们也可以将该draft参数修改为false。此时访问localhost:1313/，我们可以看到自己的博客已经显示出来： 加入一篇博文加入一篇博文 \"\r加入一篇博文\r ","date":"2020-05-09","objectID":"/posts/%E4%BD%BF%E7%94%A8hugo+github-pages%E6%9E%84%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/:4:0","tags":["Hugo","GitHub Pages"],"title":"使用Hugo+GitHub Pages构建博客网站","uri":"/posts/%E4%BD%BF%E7%94%A8hugo+github-pages%E6%9E%84%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"},{"categories":["博客搭建"],"content":"将网站部署到GitHub Pages上 首先，我们新建一个GitHub仓库blog-repo，用于存放前文所创建的所有网站文件。我们将其clone到本地，假设目录名也叫blog-repo，然后将前文中personal_blog目录下的所有文件和目录（.git除外）复制到blog-repo目录下。接下来，我们再新建一个GitHub仓库\u003cusername\u003e.github.io，用于存放Hugo最终生成的网站。这里的\u003cusername\u003e是你的GitHub用户名。然后，我们在blog-repo目录下执行以下命令： git submodule add -b master https://github.com/\u003cusername\u003e/\u003cusername\u003e.github.io.git public 上述命令会将\u003cusername\u003e.github.io仓库下载到blog-repo/public目录下。这个目录也是Hugo生成的网站默认所在的目录，所以后续生成网站之后，我们可以直接将blog-repo/public目录下的内容push到远端仓库中，这样就完成了网站在GitHub Pages上的部署。我们可以将部署过程写成一个shell script（参考自Hugo官方教程）: #!/bin/sh # If a command fails then the deploy stops set -e printf \"\\033[0;32mDeploying updates to GitHub...\\033[0m\\n\" # Build the project. hugo # if using a theme, replace with `hugo -t \u003cYOURTHEME\u003e` # Go To Public folder cd public # Add changes to git. git add . # Commit changes. msg=\"rebuilding site $(date)\" if [ -n \"$*\" ]; then msg=\"$*\" fi git commit -m \"$msg\" # Push source and build repos. git push origin master 这样每当我们撰写了新的博文，或者修改了网站设置，就可以执行上面的脚本将网站重新部署到GitHub Pages上。在Windows环境下，我们可以通过Git Bash或者Windows Subsystem for Linux来执行shell script。 ","date":"2020-05-09","objectID":"/posts/%E4%BD%BF%E7%94%A8hugo+github-pages%E6%9E%84%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/:5:0","tags":["Hugo","GitHub Pages"],"title":"使用Hugo+GitHub Pages构建博客网站","uri":"/posts/%E4%BD%BF%E7%94%A8hugo+github-pages%E6%9E%84%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"},{"categories":["博客搭建"],"content":"参考资料 https://gohugo.io/getting-started/quick-start/ https://gohugo.io/hosting-and-deployment/hosting-on-github/ https://hugoloveit.com/zh-cn/theme-documentation-basics/ https://hugoloveit.com/zh-cn/theme-documentation-content/ https://mjsmithdev.com/setting-up-hugo-on-windows/ ","date":"2020-05-09","objectID":"/posts/%E4%BD%BF%E7%94%A8hugo+github-pages%E6%9E%84%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/:6:0","tags":["Hugo","GitHub Pages"],"title":"使用Hugo+GitHub Pages构建博客网站","uri":"/posts/%E4%BD%BF%E7%94%A8hugo+github-pages%E6%9E%84%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"}]